# 技术术语手册

> **目标**: 把后端"黑话"翻译成人话，快速查阅。

---

## 📖 使用说明

**这是一本随时查阅的词典**，不需要从头到尾看。

**使用场景**:
- 看文档遇到陌生术语
- 面试前快速复习
- 写代码时忘记概念
- **向 AI 提问时需要用到的"关键词"**

**查找方法**: 按 `Ctrl+F`（Mac: `Cmd+F`）搜索术语

---

## 💡 Vibe Coding 核心提示

**重要**：这份手册是给你"看懂"用的，**不是让你背代码用的**。

- **你的任务**：理解概念（通过类比和图解）
- **AI 的任务**：写具体代码（通过你提供的术语和需求）

**每个术语下面都会给出"如何让 AI 帮你写代码"的提示词示例。**

---

## 📚 目录

1. [数据存储技术](#1-数据存储技术)
2. [架构设计模式](#2-架构设计模式)
3. [接口与通信](#3-接口与通信)
4. [身份认证](#4-身份认证)
5. [开发框架与工具](#5-开发框架与工具)
6. [部署与运维](#6-部署与运维)

---

## 1. 数据存储技术

### 1.1 MySQL / PostgreSQL（数据库）

**一句话**: 专门存储"结构化数据"的软件（像 Excel，但更强大）

**类比理解**:
```
数据库 = 图书馆的档案系统
- 每本书（数据）都有固定格式：书名、作者、ISBN、分类
- 有严格的分类规则（表结构）
- 可以快速查找（索引）
- 支持复杂查询（"找所有2020年后出版的科幻小说"）
```

**MySQL vs PostgreSQL**:

| 特性 | MySQL | PostgreSQL |
|------|-------|------------|
| 速度 | 🚀 快 | 🏃 中等 |
| 功能 | ⭐⭐ 基础 | ⭐⭐⭐ 强大 |
| 适用场景 | 简单业务 | 复杂业务 |

**我们用什么？** → **Supabase（基于 PostgreSQL）**

---

**🤖 如何让 AI 帮你？**

当你需要数据库操作时，可以这样向 AI 提问：

```
"帮我用 Supabase（PostgreSQL 数据库）创建一个用户表，
需要包含：用户名、邮箱、密码、注册时间。"
```

**你不需要懂 SQL 语法**，AI 会帮你生成创建表的代码。你只需要：
1. 说清楚要存什么数据（用户名、邮箱...）
2. 复制 AI 给的代码到 Supabase 控制台执行

---

### 1.2 Supabase（数据库云服务）

**一句话**: 不用自己搭建服务器，直接用现成的数据库服务

**类比理解**:
```
自己搭 MySQL = 自己盖房子
- 需要买地（服务器）
- 需要装修（安装配置）
- 需要维护（修 Bug、升级）

用 Supabase = 住酒店
- 拎包入住（注册即用）
- 有人维护（自动备份、升级）
- 免费额度充足（小项目够用）
```

**Supabase 提供什么？**:

```
┌─────────────────────────────────────┐
│         Supabase 全家桶              │
├─────────────────────────────────────┤
│ 🗄️  Database     │ PostgreSQL数据库  │
│ 🔐 Auth          │ 用户登录注册      │
│ 📦 Storage       │ 文件上传存储      │
│ 🔄 Realtime      │ 实时数据订阅      │
│ 🛠️  Dashboard    │ 可视化管理界面    │
└─────────────────────────────────────┘
```

---

### 1.3 OSS / Storage（对象存储）

**一句话**: 专门存储"文件"的云服务（图片、视频、PDF 等）

**类比理解**:
```
OSS = 云端的移动硬盘
- 存大文件（视频、图片、文档）
- 给每个文件一个"下载链接"
- 不适合存结构化数据（用户信息、订单等）

数据库 vs OSS:
┌──────────────┬───────────────┬─────────────┐
│   数据类型   │   存在哪里    │   例子      │
├──────────────┼───────────────┼─────────────┤
│ 结构化数据   │ 数据库        │ 用户名、价格│
│ 文件         │ OSS/Storage   │ 头像、PDF   │
└──────────────┴───────────────┴─────────────┘
```

**常见服务**:

| 服务 | 免费额度 | 适用场景 |
|------|---------|---------|\n| Supabase Storage | 1GB | 小项目（推荐） |
| 阿里云 OSS | 无 | 国内项目 |
| AWS S3 | 5GB/12个月 | 大项目 |

---

## 2. 架构设计模式

### 2.1 DAO（Data Access Object，数据访问对象）

**一句话**: 专门负责"操作数据库"的代码层

**类比理解**:
```
DAO = 仓库管理员
- 只负责存取货物（数据）
- 不关心为什么要取货（业务逻辑）
- 提供标准接口（get/create/update/delete）

你（业务层）："给我拿编号123的商品"
DAO："好的，马上去仓库找"
```

**示例代码**:

```python
class UserDAO:
    def get_by_id(self, user_id: int):        # 根据ID查询
    def get_by_username(self, username: str): # 根据用户名查询
    def create(self, data: dict):              # 创建
    def update(self, user_id: int, data: dict): # 更新
    def delete(self, user_id: int):            # 删除
```

> **⚠️ 看到代码头晕？别管它！** 这些 `def`、`self`、`:` 都是 Python 语法细节，**你不需要记**。这段代码只是让你知道 DAO 层有哪些基本操作。

---

**🤖 如何让 AI 帮你？**

当你需要数据库操作层时，向 AI 这样说：

```
"帮我用 FastAPI + Supabase 写一个 UserDAO 类，
需要实现：根据 ID 查询用户、创建用户、更新用户、删除用户。
请用 SQLAlchemy ORM。"
```

**AI 会生成完整的 DAO 代码，你只需要：**
1. 告诉 AI 需要哪些操作（查询、创建、更新...）
2. 说明是操作哪个表（用户表、文章表...）
3. 把生成的代码保存到 `dao/user_dao.py` 文件（AI 会告诉你文件名）

---

### 2.2 Service（服务层/业务逻辑层）

**一句话**: 专门负责"业务逻辑"的代码层

**类比理解**:
```
Service = 餐厅经理
- 接收顾客需求（路由层传来的请求）
- 制定处理流程（业务逻辑）
- 指挥仓库管理员（调用 DAO）

例子：顾客要点"宫保鸡丁"
经理（Service）：
1. 检查食材是否充足（业务验证）
2. 通知后厨准备（调用 DAO 查询库存）
3. 安排厨师烹饪（组合多个 DAO 操作）
4. 上菜给顾客（返回结果）
```

**Service 层的职责**:
- ✅ 业务验证（用户名是否存在、密码是否合规）
- ✅ 数据转换（密码加密、日期格式化）
- ✅ 业务流程（先创建用户→再发邮件→再记录日志）
- ✅ 调用多个 DAO（一个业务可能涉及多个表）
- ❌ 不直接操作数据库（交给 DAO）
- ❌ 不处理 HTTP 请求（交给 Router）

---

**🤖 如何让 AI 帮你？**

当你需要业务逻辑层时，向 AI 这样说：

```
"帮我用 FastAPI 写一个用户注册的 Service 层函数，
需要：
1. 检查用户名是否已存在
2. 对密码进行加密（用 bcrypt）
3. 调用 UserDAO 创建用户
4. 返回成功或失败的信息"
```

**AI 会生成完整的 Service 代码，你只需要：**
1. 描述清楚业务流程（先做什么，后做什么）
2. 说明需要什么验证（用户名重复？密码长度？）
3. 把代码保存到 `services/user_service.py` 文件

---

### 2.3 Router / Controller（路由层/控制器层）

**一句话**: 专门负责"接收请求、返回响应"的代码层

**类比理解**:
```
Router = 餐厅服务员
- 接待客户（接收 HTTP 请求）
- 记录点单（解析请求参数）
- 转交后厨（调用 Service）
- 上菜（返回响应）

服务员不做菜（不写业务逻辑），只负责传话
```

**三层架构流程**:

```
用户请求 → Router（接待） → Service（处理） → DAO（存取） → 数据库
         ↓
      返回响应 ← Router（送菜） ← Service（做菜） ← DAO（取食材）
```

---

## 3. 接口与通信

### 3.1 API（Application Programming Interface，应用程序接口）

**一句话**: 软件之间"对话"的标准规则

**类比理解**:
```
API = 餐厅的菜单
- 菜单上写了"宫保鸡丁 ¥38"（接口文档）
- 你不需要知道怎么做菜（后端实现细节）
- 只需要说"来一份宫保鸡丁"（发请求）
- 厨师按标准做好端给你（返回响应）
```

**API 的组成**:

```
POST https://api.example.com/users/register
     ────────────────────── ──────────────
            基础URL              路径

Headers:（请求头）
    Content-Type: application/json
    Authorization: Bearer token123

Body:（请求体）
    {
        "username": "zhangsan",
        "password": "123456"
    }

Response:（响应）
    {
        "code": 200,
        "msg": "注册成功",
        "data": {"user_id": 123}
    }
```

---

### 3.2 RESTful API（REST 风格的 API）

**一句话**: 用"URL 表示资源、HTTP 方法表示操作"的 API 设计规范

**类比理解**:
```
RESTful = 图书馆的统一管理规则

不遵守规则的图书馆：
- "我要借《三体》" → 去3号窗口
- "我要还《三体》" → 去8号窗口
- "我要续借《三体》" → 去15号窗口
混乱！

遵守 REST 规则的图书馆：
- 都去"图书管理窗口"
- 用不同的操作卡：借书卡、还书卡、续借卡
统一！

对应到 API：
GET    /books/123  →  借书（获取）
POST   /books      →  买新书（创建）
PUT    /books/123  →  换书（更新）
DELETE /books/123  →  扔掉书（删除）
```

**RESTful 的核心原则**:

| 操作 | HTTP方法 | 示例 |
|------|---------|------|
| 查询 | GET | `GET /api/users/123` |
| 创建 | POST | `POST /api/users` |
| 完整更新 | PUT | `PUT /api/users/123` |
| 部分更新 | PATCH | `PATCH /api/users/123` |
| 删除 | DELETE | `DELETE /api/users/123` |

---

### 3.3 HTTP（超文本传输协议）

**一句话**: 浏览器和服务器之间"说话"的语言

**常用状态码**:

| 状态码 | 含义 | 使用场景 | **报错了怎么办？** |
|--------|------|----------|--------------------|
| 200 OK | 成功 | 请求成功 | - |
| 201 Created | 已创建 | 创建资源成功 | - |
| 400 Bad Request | 请求错误 | 参数格式错误 | **检查你发送的数据格式**（邮箱格式对吗？必填项都填了吗？）→ 让 AI 帮你检查 Pydantic 验证规则 |
| 401 Unauthorized | 未授权 | 未登录或 token 无效 | **检查登录状态**（Token 过期了？忘记带 Token？）→ 重新登录获取新 Token |
| 403 Forbidden | 禁止访问 | 没有权限 | **检查权限配置**（这个用户有访问权限吗？）→ 去后台修改用户角色或 CORS 配置 |
| 404 Not Found | 未找到 | 资源不存在 | **检查 URL 路径**（是不是打错了？资源被删了？）→ 确认接口地址和资源 ID |
| 500 Server Error | 服务器错误 | 服务器内部错误 | **不是你的问题！** 这是后端代码出 Bug 了 → 查看后端日志（或让 AI 分析报错信息） |

---

**🔍 报错时的 Vibe Coding 流程**：

1. **看状态码** → 知道大概哪里出问题（是前端问题还是后端问题）
2. **复制完整报错信息** → 包括状态码、错误消息、堆栈信息（如果有）
3. **问 AI** → "我的 FastAPI 接口返回 403 错误，完整报错是：[粘贴报错]，可能是什么原因？怎么修复？"
4. **按 AI 建议操作** → AI 会告诉你去哪个文件改什么配置

---

## 4. 身份认证

### 4.1 Token（令牌）

**一句话**: 登录后获得的"临时通行证"

**类比理解**:
```
Token = 游乐园的手环
- 第一次入园：验证门票（账号密码） → 工作人员给你戴手环（Token）
- 后续玩项目：出示手环（带 Token 请求） → 直接放行
- 手环有效期：当天（Token 过期时间）
- 离开后失效：第二天来需要重新买票（Token 过期需重新登录）
```

**为什么用 Token 而不是每次输密码？**:
- ❌ 密码在网络传输不安全
- ❌ 每次输密码用户体验差
- ✅ Token 可以设置过期时间
- ✅ Token 可以随时撤销（比如登出）

---

### 4.2 JWT（JSON Web Token）

**一句话**: 一种"自包含信息"的 Token 格式

**类比理解**:
```
普通 Token = 图书馆借书卡号（123456）
- 看到卡号 123456
- 需要去系统查：这是谁的卡？有效吗？
- 需要数据库查询 ⏱️

JWT = 带照片的身份证
- 身份证上直接写了：姓名、年龄、地址
- 不需要查询，直接看身份证就知道是谁
- 不需要数据库查询 ⚡
```

**JWT 的结构**:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsImV4cCI6MTcwMDAwMDAwMH0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
────────────────────────────────── ─────────────────────────────────────────────────────────── ──────────────────────────────────────────────
         Header（头部）                            Payload（负载）                                    Signature（签名）
      算法类型：HS256                     用户信息：user_id=123, exp=过期时间                   用密钥生成，防篡改
```

> **⚠️ 看到这一大串乱码害怕了？别担心！**
> - 这串乱码**不是你打出来的**，是系统自动生成的。
> - 你只需要知道 JWT = "加密的用户信息卡片"，具体怎么加密让 AI 写。
> - **你不需要懂加密算法**，就像你不需要知道银行卡芯片怎么工作，只要会刷卡就行。

---

**🤖 如何让 AI 帮你？**

当你需要实现 JWT 登录验证时，向 AI 这样说：

```
"帮我用 FastAPI 实现 JWT 登录功能：
1. 用户登录成功后生成 JWT Token
2. Token 里包含用户 ID 和过期时间（24小时）
3. 提供一个验证 Token 的函数，用于保护需要登录的接口
请使用 python-jose 库。"
```

**AI 会生成完整的 JWT 代码，你只需要：**
1. 说明 Token 里要包含哪些信息（用户 ID、角色...）
2. 设置过期时间（1天、7天...）
3. 把代码保存到 `auth/jwt_handler.py` 文件

---

## 5. 开发框架与工具

### 5.1 FastAPI（Python Web 框架）

**一句话**: 快速开发 API 后端的 Python 框架

**为什么选 FastAPI？**:

| 特性 | FastAPI | Django | Flask |
|------|---------|--------|-------|
| 学习曲线 | ⭐⭐ 中等 | ⭐⭐⭐ 较陡 | ⭐ 简单 |
| 开发速度 | 🚀 极快 | 🐢 慢 | 🏃 快 |
| 性能 | ⚡ 最快 | 🐌 一般 | 🏃 中等 |
| 自动文档 | ✅ 自动生成 | ❌ 需手写 | ❌ 需手写 |
| 适用场景 | API 后端 | 大型全栈 | 简单后端 |

**核心特性**:
- 📝 访问 `/docs` 自动生成 Swagger UI 文档
- ✅ Pydantic 自动验证请求数据
- 🚀 异步支持，性能接近 Node.js

---

### 5.2 SQLAlchemy（ORM 框架）

**一句话**: 用 Python 代码操作数据库，不写 SQL

**类比理解**:
```
原始 SQL = 手写信
- SELECT * FROM users WHERE username = 'zhangsan'
- 容易写错、难以复用

SQLAlchemy = 用表单填空
- db.query(User).filter(User.username == 'zhangsan').first()
- 类型安全、IDE 自动补全
```

**ORM 是什么？**:

```
ORM = Object-Relational Mapping（对象关系映射）

数据库的表 ←→ Python 的类
表的行     ←→ 类的实例
表的列     ←→ 类的属性

users表                      User类
┌────┬──────────┬───────┐   class User:
│ id │ username │ email │       id = Column(Integer)
├────┼──────────┼───────┤       username = Column(String)
│ 1  │ zhangsan │ ...   │       email = Column(String)
└────┴──────────┴───────┘
```

---

### 5.3 Pydantic（数据验证库）

**一句话**: 自动验证数据格式是否正确

**类比理解**:
```
Pydantic = 机场安检
- 定义规则：液体不超过100ml、不能带刀具
- 自动检查：X 光机扫描
- 不合格：拦下并告知原因
```

**示例**:

```python
from pydantic import BaseModel, Field, EmailStr

class UserRegisterRequest(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=6)
    email: EmailStr  # 自动验证邮箱格式

# FastAPI 中使用
@app.post("/api/users/register")
def register(user: UserRegisterRequest):
    # FastAPI 自动验证所有规则
    # 验证失败自动返回详细错误信息
    return {"msg": "注册成功"}
```

> **⚠️ 看到 `BaseModel`、`Field` 头晕？别管语法细节！**
> - 这些 `Field(..., min_length=3)` 是 Pydantic 的规则写法，AI 会帮你写。
> - **你只需要知道**：Pydantic = 自动检查数据的"质检员"，用中文告诉 AI 你要检查什么就行。

---

**🤖 如何让 AI 帮你？**

当你需要数据验证时，向 AI 这样说：

```
"帮我用 Pydantic 写一个用户注册的数据验证模型，要求：
- 用户名：3-50个字符
- 密码：至少6个字符
- 邮箱：必须是有效邮箱格式
- 手机号（可选）：必须是11位数字"
```

**AI 会生成完整的 Pydantic 模型代码，你只需要：**
1. 用中文描述每个字段的验证规则（长度、格式、必填/可选）
2. 把代码保存到 `models/schemas.py` 文件（或者问 AI："这个代码应该放在哪个文件？"）
3. 在 Router 里引用这个模型（AI 会告诉你怎么引用）

**实操示例（在哪里写代码）**：
1. **打开 VS Code** → 找到项目文件夹
2. **创建文件** → 在 `models` 文件夹下新建 `schemas.py`（如果没有这个文件夹，让 AI 告诉你项目结构）
3. **粘贴代码** → 把 AI 生成的 Pydantic 代码粘贴进去
4. **保存** → `Ctrl+S` / `Cmd+S`

---

## 6. 部署与运维

### 6.1 Vercel（无服务器部署平台）

**一句话**: 把代码推到 GitHub，Vercel 自动部署上线（不用自己管服务器）

**类比理解**:
```
传统部署 = 自己开餐厅
- 租店铺（买服务器）¥500/月
- 装修（安装 Linux、配置环境）
- 招服务员（运维人员）
- 付水电费（服务器电费、带宽）

Vercel 部署 = 在美团开店
- 入驻即用（注册账号）
- 平台管理（自动扩容、备份）
- 按单收费（免费额度很大）
```

**工作流程**:

```
1. 本地开发 → 写代码、测试
2. 推送到 GitHub → git push origin main（在终端/命令行输入）
3. Vercel 自动检测 → 自动构建、自动部署
4. 生成访问链接 → https://your-app.vercel.app
```

> **❓ "git push" 是在哪里输入的？**
> - **方法1（推荐新手）**：使用 VS Code 的图形界面
>   1. 点击左侧"源代码管理"图标（三个小圆点连线的那个）
>   2. 填写提交信息（比如"添加用户注册功能"）
>   3. 点击"提交"按钮（✓）
>   4. 点击"同步更改"（↻）→ 自动推送到 GitHub
> - **方法2（命令行）**：在 VS Code 终端输入 `git push origin main`
>   - 打开方式：菜单栏 → 终端 → 新建终端

---

### 6.2 环境变量（Environment Variables）

**一句话**: 不同环境（开发/测试/生产）使用不同的配置

**类比理解**:
```
环境变量 = 餐厅的不同模式

开发环境（本地）：
- 用测试数据库（随便改）
- 开启调试模式（显示详细错误）
- API 地址：http://localhost:8000

生产环境（线上）：
- 用正式数据库（真实用户数据）
- 关闭调试模式（不暴露错误细节）
- API 地址：https://api.example.com
```

**为什么需要环境变量？**:

```python
# ❌ 硬编码（不好）
DATABASE_URL = "postgresql://user:password@localhost/mydb"
# 问题：密码暴露在代码里、推送到 GitHub 泄露

# ✅ 使用环境变量（推荐）
import os
DATABASE_URL = os.getenv("DATABASE_URL")
# 不同环境配置不同的值
```

> **⚠️ 看到 Python 代码不要慌！** 这里只是展示原理，实际操作很简单（往下看实操步骤）。

---

**🤖 如何让 AI 帮你？** + **📝 实操指南**

**场景**：你需要在项目里配置 Supabase 数据库连接。

**第1步：问 AI 需要哪些环境变量**
```
"我要用 FastAPI 连接 Supabase 数据库，需要配置哪些环境变量？"
```
AI 会告诉你需要：`SUPABASE_URL`、`SUPABASE_KEY` 等。

**第2步：在本地创建 .env 文件**（开发环境）
1. 在项目根目录（和 `main.py` 同级）新建文件，命名为 `.env`
2. 在文件里写（AI 会给你格式）：
   ```
   SUPABASE_URL=https://your-project.supabase.co
   SUPABASE_KEY=your_secret_key_here
   ```
3. **重要**：在 `.gitignore` 文件里加一行 `.env`（防止密码上传到 GitHub）

**第3步：在 Vercel 配置环境变量**（生产环境）
1. 打开 Vercel 项目设置 → Settings → Environment Variables
2. 添加同样的变量名和值（这里填真实生产环境的密钥）
3. 点击"Save" → 重新部署项目

**让 AI 帮你写读取环境变量的代码**：
```
"帮我用 Python 的 python-dotenv 库读取 .env 文件里的 SUPABASE_URL 和 SUPABASE_KEY"
```
AI 会生成类似这样的代码（你直接复制到 `config.py` 文件）。

---

### 6.3 CORS（跨域资源共享）

**一句话**: 允许前端（不同域名）访问后端 API

**类比理解**:
```
CORS = 海关
- 浏览器安全策略：不同"国家"（域名）之间不能随意往来
- 前端（http://localhost:3000）想访问后端（http://localhost:8000）→ 被拦截
- 配置 CORS = 办签证：后端告诉浏览器"允许这个域名访问"
```

**FastAPI 配置**:

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",      # 开发环境前端
        "https://your-app.vercel.app" # 生产环境前端
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

## 📊 快速检索

**我想...**

| 需求 | 查看术语 |
|------|---------|\n| 存储用户信息 | [MySQL/PostgreSQL](#11-mysql--postgresql数据库) |
| 不想自己搭数据库 | [Supabase](#12-supabase数据库云服务) |
| 存储图片/文件 | [OSS/Storage](#13-oss--storage对象存储) |
| 代码不混乱 | [DAO/Service/Router](#2-架构设计模式) |
| 前后端通信 | [API](#31-api应用程序接口) |
| URL 规范设计 | [RESTful](#32-restful-apirest-风格的-api) |
| 用户登录验证 | [JWT](#42-jwtjson-web-token) |
| 快速开发后端 | [FastAPI](#51-fastapipython-web-框架) |
| 用代码操作数据库 | [SQLAlchemy](#52-sqlalchemyorm-框架) |
| 自动验证数据 | [Pydantic](#53-pydantic数据验证库) |
| 部署上线 | [Vercel](#61-vercel无服务器部署平台) |
| 前端访问报错 | [CORS](#63-cors跨域资源共享) |

---

## 💡 使用建议

**遇到不懂的术语：**

1. 在本文档按 `Ctrl+F` 搜索
2. 看"一句话"和"类比理解"
3. 还不懂就问 AI：
   > "我不理解 [术语名] 是什么，能用日常生活的例子给我解释吗？"

**记住**: 术语只是名字，背后的概念才重要。看懂类比，就理解了 80%。

---

## 📚 返回目录

👉 [后端开发基础](./README.md)

查看完整学习路径。
